from pathlib import Path
import re
from collections import OrderedDict


class RapsDependencyFile(object):
    """
    Wrapper class for GNUmake-style dependency files generated by RAPS.
    """

    def __init__(self, content=None, path=None):
        self.path = path
        self.content = content or []

    @classmethod
    def from_file(cls, path):
        re_deps = re.compile('(?P<target>.*):\s(?P<deps>[\s\S]*)', re.MULTILINE)
        re_assign = re.compile('(?P<target>.*)\s=\s(?P<objs>[\s\S]*)', re.MULTILINE)

        path = Path(path)
        with path.open('r') as f:
            source = f.read()

        content = []
        for block in source.split('\n\n'):
            deps = re_deps.search(block)
            if deps is not None:
                groups = deps.groupdict()
                deps = groups['deps'].split(' \\\n\t')
                deps = [d.strip() for d in deps]
                content.append(Dependency(target=groups['target'], deps=deps))

            assign = re_assign.search(block)
            if assign is not None:
                groups = assign.groupdict()
                objects = groups['objs']
                objects = objects.split('#')[0] if '#' in objects else objects
                objects = [o.strip() for o in objects.split(' \\\n\t')]
                content.append(Assignment(target=groups['target'], objects=objects))

        return cls(content=content, path=path)

    @property
    def content_map(self):
        return {d.target: d for d in self.content}

    def write(self, path=None):
        path = path or self.path

        content = """#
#--- Automatically generated -- please do not edit this file
#

"""
        content += '\n\n'.join(str(c) for c in self.content)
        with Path(path).open('w') as f:
            f.write(content)

    def replace(self, key, replacement):
        """
        Replace specific rule/assignment with another based on the
        targets name as a key.
        """
        for i, o in enumerate(self.content):
            if o.target == key:
                self.content[i] = replacement


class Dependency(object):

    def __init__(self, target, deps):
        self.target = target
        self.deps = deps

    def __repr__(self):
        deps = ' \\\n\t'.join(self.deps)
        return '%s: %s' % (self.target, deps)

    def replace(self, target, replacement):
        if target in self.target:
            self.target = self.target.replace(target, replacement)
        for i, dep in enumerate(self.deps):
            if target in dep:
                self.deps[i] = dep.replace(target, replacement)


class Assignment(object):

    def __init__(self, target, objects):
        self.target = target
        self.objects = objects

    def __repr__(self):
        objects = ' \\\n\t'.join(self.objects)
        return '%s = %s' % (self.target, objects)

    def replace(self, target, replacement):
        if target in self.target:
            self.target = self.target.replace(target, replacement)
        for i, obj in enumerate(self.objects):
            if target in obj:
                self.objects[i] = obj.replace(target, replacement)

    def append_inplace(self, target, replacement):
        for i, obj in enumerate(self.objects):
            if target in obj:
                new = obj.replace(target, replacement)
                self.objects[i:i+1] = [obj, new]


class Rule(object):

    def __init__(self, target, deps, cmds):
        self.target = target
        self.deps = deps
        self.cmds = cmds

    def __repr__(self):
        deps = ' '.join(self.deps)
        cmds = ' \n\t'.join(self.cmds)
        return '%s: %s \n\t%s' % (self.target, deps, cmds)
